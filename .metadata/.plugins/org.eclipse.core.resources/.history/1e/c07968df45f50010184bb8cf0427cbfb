package com.example.demo.Controller;

import java.time.LocalDateTime;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.web.bind.annotation.*;

import com.example.demo.entity.Notification;
import com.example.demo.entity.Order;
import com.example.demo.entity.OrderStatus;
import com.example.demo.entity.Product;
import com.example.demo.entity.User;
import com.example.demo.repository.NotificationRepository;
import com.example.demo.repository.OrderRepository;
import com.example.demo.repository.ProductRepository;
import com.example.demo.repository.UserRepository;
import com.example.demo.services.EmailService;

@RestController
@RequestMapping("/api/orders")
@CrossOrigin(origins = "http://localhost:3000")
public class OrderController {

    @Autowired
    private OrderRepository orderRepository;

    @Autowired
    private ProductRepository productRepository;

    @Autowired
    private UserRepository userRepository;

    @Autowired
    private NotificationRepository notificationRepository;

    @Autowired
    private EmailService emailService;

    // ================= PLACE ORDER =================
    @PostMapping
    @Transactional
    public Map<String, Object> placeOrder(@RequestBody Map<String, Object> data) {

        Long productId = Long.parseLong(data.get("productId").toString());
        Long retailerId = Long.parseLong(data.get("retailerId").toString());
        int qty = Integer.parseInt(data.get("quantity").toString());

        if (qty <= 0) {
            throw new RuntimeException("Quantity must be greater than 0");
        }

        Product product = productRepository.findById(productId)
                .orElseThrow(() -> new RuntimeException("Product not found"));

        if (product.getQuantity() < qty) {
            throw new RuntimeException("Insufficient stock");
        }

        User retailer = userRepository.findById(retailerId)
                .orElseThrow(() -> new RuntimeException("Retailer not found"));

        // ✅ Reduce stock immediately when order placed
        product.setQuantity(product.getQuantity() - qty);
        productRepository.save(product);

        // ✅ Calculate total amount
        Double totalAmount = product.getPrice() * qty;

        // ✅ Create order
        Order order = new Order();
        order.setProduct(product);
        order.setRetailer(retailer);
        order.setQuantity(qty);
        order.setStatus(OrderStatus.PLACED);
        order.setOrderDate(LocalDateTime.now());
        order.setPaymentStatus("PENDING");
        order.setTotalAmount(totalAmount);

        Order savedOrder = orderRepository.save(order);

        // ✅ Response
        Map<String, Object> response = new HashMap<>();
        response.put("orderId", savedOrder.getId());
        response.put("totalAmount", totalAmount);
        response.put("productName", product.getName());
        response.put("quantity", qty);

        return response;
    }

    // ================= RETAILER ORDERS =================
    @GetMapping("/retailer/{retailerId}")
    public List<Order> getRetailerOrders(@PathVariable Long retailerId) {
        return orderRepository.findByRetailerId(retailerId);
    }

    // ================= FARMER ORDERS =================
    @GetMapping("/farmer/{farmerId}")
    public List<Order> getFarmerOrders(@PathVariable Long farmerId) {
        return orderRepository.findByProductFarmerId(farmerId);
    }

    // ================= RETAILER EDIT ORDER =================
    @PutMapping("/retailer/{orderId}/edit")
    @Transactional
    public Order editOrderByRetailer(
            @PathVariable Long orderId,
            @RequestBody Map<String, Object> data
    ) {
        Long retailerId = Long.parseLong(data.get("retailerId").toString());
        int newQty = Integer.parseInt(data.get("quantity").toString());

        if (newQty <= 0) {
            throw new RuntimeException("Quantity must be greater than 0");
        }

        Order order = orderRepository.findById(orderId)
                .orElseThrow(() -> new RuntimeException("Order not found"));

        // ✅ Only same retailer can edit
        if (!order.getRetailer().getId().equals(retailerId)) {
            throw new RuntimeException("You are not allowed to edit this order");
        }

        // ✅ Cannot edit delivered/cancelled
        if (order.getStatus() == OrderStatus.DELIVERED || order.getStatus() == OrderStatus.CANCELLED) {
            throw new RuntimeException("Cannot edit delivered/cancelled order");
        }

        Product product = order.getProduct();

        int oldQty = order.getQuantity();
        int diff = newQty - oldQty;

        // If increasing qty -> require stock
        if (diff > 0 && product.getQuantity() < diff) {
            throw new RuntimeException("Insufficient stock to increase quantity");
        }

        // ✅ Update stock accordingly
        product.setQuantity(product.getQuantity() - diff);
        productRepository.save(product);

        // ✅ Update order
        order.setQuantity(newQty);
        order.setStatus(OrderStatus.MODIFIED);
        order.setTotalAmount(product.getPrice() * newQty);

        return orderRepository.save(order);
    }

    // ================= RETAILER CANCEL ORDER =================
    @PutMapping("/retailer/{orderId}/cancel")
    @Transactional
    public Order cancelOrderByRetailer(
            @PathVariable Long orderId,
            @RequestBody Map<String, Object> data
    ) {
        Long retailerId = Long.parseLong(data.get("retailerId").toString());

        Order order = orderRepository.findById(orderId)
                .orElseThrow(() -> new RuntimeException("Order not found"));

        // ✅ Only same retailer can cancel
        if (!order.getRetailer().getId().equals(retailerId)) {
            throw new RuntimeException("You are not allowed to cancel this order");
        }

        // ✅ Cannot cancel delivered
        if (order.getStatus() == OrderStatus.DELIVERED) {
            throw new RuntimeException("Delivered order cannot be cancelled");
        }

        if (order.getStatus() == OrderStatus.CANCELLED) {
            return order;
        }

        // ✅ Restore stock
        Product product = order.getProduct();
        product.setQuantity(product.getQuantity() + order.getQuantity());
        productRepository.save(product);

        order.setStatus(OrderStatus.CANCELLED);
        order.setPaymentStatus("FAILED"); // or "CANCELLED"

        return orderRepository.save(order);
    }

    // ================= FARMER DASHBOARD SUMMARY =================
    @GetMapping("/farmer/{farmerId}/summary")
    public Map<String, Object> getFarmerDashboardSummary(@PathVariable Long farmerId) {

        Map<String, Object> response = new HashMap<>();

        response.put("totalOrders", orderRepository.countByFarmerId(farmerId));

        response.put(
                "processingOrders",
                orderRepository.countByFarmerIdAndStatusIn(
                        farmerId, List.of(OrderStatus.PLACED, OrderStatus.PROCESSING, OrderStatus.MODIFIED)
                )
        );

        response.put(
                "cancelledOrders",
                orderRepository.countByFarmerIdAndStatus(farmerId, OrderStatus.CANCELLED)
        );

        response.put(
                "deliveredOrders",
                orderRepository.countByFarmerIdAndStatus(farmerId, OrderStatus.DELIVERED)
        );

        // ✅ Revenue should count DELIVERED orders, not CANCELLED
        response.put(
                "totalRevenue",
                orderRepository.sumRevenueByFarmerId(farmerId, OrderStatus.DELIVERED)
        );

        return response;
    }

    // ================= FARMER SALES ANALYTICS =================
    @GetMapping("/farmer/{farmerId}/analytics")
    public Map<String, Object> getFarmerSalesAnalytics(@PathVariable Long farmerId) {
        Map<String, Object> response = new HashMap<>();

        // Completed transactions
        List<Order> completedOrders = orderRepository.findByProductFarmerIdAndStatus(farmerId, OrderStatus.DELIVERED);
        response.put("completedTransactions", completedOrders);

        // ✅ Total revenue from delivered orders
        Double totalRevenue = orderRepository.sumRevenueByFarmerId(farmerId, OrderStatus.DELIVERED);
        response.put("totalRevenue", totalRevenue);

        // Monthly data
        List<Object[]> monthlyTransactions = orderRepository.getMonthlyTransactionCounts(farmerId, OrderStatus.DELIVERED);
        Map<String, Integer> monthlyTransactionData = new HashMap<>();
        String[] monthNames = {"January", "February", "March", "April", "May", "June",
                "July", "August", "September", "October", "November", "December"};

        for (Object[] row : monthlyTransactions) {
            int monthIndex = ((Number) row[0]).intValue() - 1;
            int count = ((Number) row[1]).intValue();
            if (monthIndex >= 0 && monthIndex < 12) {
                monthlyTransactionData.put(monthNames[monthIndex], count);
            }
        }
        response.put("monthlyTransactions", monthlyTransactionData);

        // Top sold products
        List<Object[]> topProducts = orderRepository.getTopSoldProducts(farmerId, OrderStatus.DELIVERED);
        List<Map<String, Object>> topProductsData = new java.util.ArrayList<>();

        for (Object[] row : topProducts) {
            Map<String, Object> product = new HashMap<>();
            product.put("name", row[0]);
            product.put("quantity", ((Number) row[1]).intValue());
            topProductsData.add(product);
        }
        response.put("topSoldProducts", topProductsData);

        return response;
    }

    // ================= ✅ RETAILER ANALYTICS (NEW) =================
    @GetMapping("/retailer/{retailerId}/analytics")
    public Map<String, Object> getRetailerAnalytics(@PathVariable Long retailerId) {

        Map<String, Object> response = new HashMap<>();

        long totalOrders = orderRepository.countByRetailerId(retailerId);
        long placedOrders = orderRepository.countByRetailerIdAndStatus(retailerId, OrderStatus.PLACED);
        long modifiedOrders = orderRepository.countByRetailerIdAndStatus(retailerId, OrderStatus.MODIFIED);
        long processingOrders = orderRepository.countByRetailerIdAndStatus(retailerId, OrderStatus.PROCESSING);
        long deliveredOrders = orderRepository.countByRetailerIdAndStatus(retailerId, OrderStatus.DELIVERED);
        long cancelledOrders = orderRepository.countByRetailerIdAndStatus(retailerId, OrderStatus.CANCELLED);

        Double totalSpent = orderRepository.sumRevenueByRetailerId(retailerId, OrderStatus.DELIVERED);
        if (totalSpent == null) totalSpent = 0.0;

        response.put("totalOrders", totalOrders);
        response.put("placedOrders", placedOrders);
        response.put("modifiedOrders", modifiedOrders);
        response.put("processingOrders", processingOrders);
        response.put("deliveredOrders", deliveredOrders);
        response.put("cancelledOrders", cancelledOrders);
        response.put("totalSpent", totalSpent);

        // Monthly transaction data (DELIVERED)
        List<Object[]> monthly = orderRepository.getMonthlyRetailerTransactions(retailerId, OrderStatus.DELIVERED);
        Map<String, Integer> monthlyTransactionData = new HashMap<>();
        String[] monthNames = {"January", "February", "March", "April", "May", "June",
                "July", "August", "September", "October", "November", "December"};

        for (Object[] row : monthly) {
            int monthIndex = ((Number) row[0]).intValue() - 1;
            int count = ((Number) row[1]).intValue();
            if (monthIndex >= 0 && monthIndex < 12) {
                monthlyTransactionData.put(monthNames[monthIndex], count);
            }
        }
        response.put("monthlyTransactions", monthlyTransactionData);

        // Top purchased products
        List<Object[]> topProducts = orderRepository.getTopSoldProducts(retailerId, OrderStatus.DELIVERED);
        List<Map<String, Object>> topProductsData = new java.util.ArrayList<>();

        for (Object[] row : topProducts) {
            Map<String, Object> product = new HashMap<>();
            product.put("name", row[0]);
            product.put("quantity", ((Number) row[1]).intValue());
            topProductsData.add(product);
        }
        response.put("topPurchasedProducts", topProductsData);

        return response;
    }

    // ================= ADMIN: GET ALL ORDERS =================
    @GetMapping("/admin")
    public List<Order> getAllOrdersForAdmin() {
        return orderRepository.findAll();
    }

    // ================= UPDATE ORDER STATUS (ADMIN) =================
    @PutMapping("/admin/{orderId}/status")
    @Transactional
    public Order updateOrderStatus(
            @PathVariable Long orderId,
            @RequestBody Map<String, String> data
    ) {
        Order order = orderRepository.findById(orderId)
                .orElseThrow(() -> new RuntimeException("Order not found"));

        OrderStatus newStatus = OrderStatus.valueOf(data.get("status"));
        order.setStatus(newStatus);

        // Notify farmer
        Notification farmerNotification = new Notification();
        farmerNotification.setUserId(order.getProduct().getFarmer().getId());
        farmerNotification.setMessage("Order #" + order.getId() + " status updated to " + newStatus);
        farmerNotification.setRead(false);
        farmerNotification.setCreatedAt(LocalDateTime.now());
        notificationRepository.save(farmerNotification);

        // Notify retailer
        Notification retailerNotification = new Notification();
        retailerNotification.setUserId(order.getRetailer().getId());
        retailerNotification.setMessage("Your order #" + order.getId() + " status updated to " + newStatus);
        retailerNotification.setRead(false);
        retailerNotification.setCreatedAt(LocalDateTime.now());
        notificationRepository.save(retailerNotification);

        // Emails
        emailService.sendOrderStatusNotification(
                order.getProduct().getFarmer().getEmail(),
                order.getId().toString(),
                newStatus.toString()
        );

        emailService.sendOrderStatusNotification(
                order.getRetailer().getEmail(),
                order.getId().toString(),
                newStatus.toString()
        );

        return orderRepository.save(order);
    }

    // ================= CANCEL ORDER (ADMIN) =================
    @PutMapping("/admin/{orderId}/cancel")
    @Transactional
    public Order cancelOrderAdmin(@PathVariable Long orderId) {

        Order order = orderRepository.findById(orderId)
                .orElseThrow(() -> new RuntimeException("Order not found"));

        if (order.getStatus() == OrderStatus.CANCELLED) {
            return order;
        }

        // Restore stock
        Product product = order.getProduct();
        product.setQuantity(product.getQuantity() + order.getQuantity());
        productRepository.save(product);

        order.setStatus(OrderStatus.CANCELLED);
        order.setPaymentStatus("FAILED");

        return orderRepository.save(order);
    }

    // ================= ADMIN REVENUE =================
    @GetMapping("/admin/revenue")
    public Map<String, Object> getAdminRevenue() {
        Map<String, Object> response = new HashMap<>();
        response.put("totalRevenue", orderRepository.getTotalRevenue(OrderStatus.DELIVERED));
        return response;
    }

    // ================= RETAILER REVENUE =================
    @GetMapping("/retailer/{retailerId}/revenue")
    public Map<String, Object> getRetailerRevenue(@PathVariable Long retailerId) {
        Map<String, Object> response = new HashMap<>();
        response.put("totalRevenue", orderRepository.sumRevenueByRetailerId(retailerId, OrderStatus.DELIVERED));
        return response;
    }

    // ================= ADMIN ORDER COUNT =================
    @GetMapping("/admin/count")
    public long getOrderCount() {
        return orderRepository.getTotalOrders();
    }
}
