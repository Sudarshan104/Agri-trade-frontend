package com.example.demo.Controller;

import java.time.LocalDateTime;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.web.bind.annotation.*;

import com.example.demo.entity.Notification;
import com.example.demo.entity.Order;
import com.example.demo.entity.OrderStatus;
import com.example.demo.entity.Product;
import com.example.demo.entity.User;
import com.example.demo.repository.NotificationRepository;
import com.example.demo.repository.OrderRepository;
import com.example.demo.repository.ProductRepository;
import com.example.demo.repository.UserRepository;
import com.example.demo.services.EmailService;

@RestController
@RequestMapping("/api/orders")
@CrossOrigin(origins = "http://localhost:3000")
public class OrderController {

    @Autowired
    private OrderRepository orderRepository;

    @Autowired
    private ProductRepository productRepository;

    @Autowired
    private UserRepository userRepository;

    @Autowired
    private NotificationRepository notificationRepository;

    @Autowired
    private EmailService emailService;

    // ================= PLACE ORDER =================
    @PostMapping
    @Transactional
    public Map<String, Object> placeOrder(@RequestBody Map<String, Object> data) {

        Long productId = Long.parseLong(data.get("productId").toString());
        Long retailerId = Long.parseLong(data.get("retailerId").toString());
        int qty = Integer.parseInt(data.get("quantity").toString());

        Product product = productRepository.findById(productId)
                .orElseThrow(() -> new RuntimeException("Product not found"));

        if (product.getQuantity() < qty) {
            throw new RuntimeException("Insufficient stock");
        }

        User retailer = userRepository.findById(retailerId)
                .orElseThrow(() -> new RuntimeException("Retailer not found"));

        // Calculate total amount
        Double totalAmount = product.getPrice() * qty;

        // Create order with PENDING payment status
        Order order = new Order();
        order.setProduct(product);
        order.setRetailer(retailer);
        order.setQuantity(qty);
        order.setStatus(OrderStatus.PLACED);
        order.setOrderDate(LocalDateTime.now());
        order.setPaymentStatus("PENDING");
        order.setTotalAmount(totalAmount);

        Order savedOrder = orderRepository.save(order);

        // Return order details for payment processing
        Map<String, Object> response = new HashMap<>();
        response.put("orderId", savedOrder.getId());
        response.put("totalAmount", totalAmount);
        response.put("productName", product.getName());
        response.put("quantity", qty);

        return response;
    }

    // ================= RETAILER ORDERS =================
    @GetMapping("/retailer/{retailerId}")
    public List<Order> getRetailerOrders(@PathVariable Long retailerId) {
        return orderRepository.findByRetailerId(retailerId);
    }

    // ================= FARMER ORDERS =================
    @GetMapping("/farmer/{farmerId}")
    public List<Order> getFarmerOrders(@PathVariable Long farmerId) {
        return orderRepository.findByProductFarmerId(farmerId);
    }

    // ================= FARMER DASHBOARD SUMMARY (âœ… FIXED) =================
    @GetMapping("/farmer/{farmerId}/summary")
    public Map<String, Object> getFarmerDashboardSummary(@PathVariable Long farmerId) {

        Map<String, Object> response = new HashMap<>();

        response.put(
            "totalOrders",
            orderRepository.countByFarmerId(farmerId)
        );

        // Include both PLACED and PROCESSING orders as "processing"
        response.put(
            "processingOrders",
            orderRepository.countByFarmerIdAndStatusIn(
                farmerId, List.of(OrderStatus.PLACED, OrderStatus.PROCESSING)
            )
        );

        response.put(
            "cancelledOrders",
            orderRepository.countByFarmerIdAndStatus(
                farmerId, OrderStatus.CANCELLED
            )
        );

        response.put(
            "deliveredOrders",
            orderRepository.countByFarmerIdAndStatus(
                farmerId, OrderStatus.DELIVERED
            )
        );

        response.put(
            "totalRevenue",
            orderRepository.sumRevenueByFarmerId(
                farmerId, OrderStatus.CANCELLED
            )
        );

        return response;
    }

    // ================= FARMER SALES ANALYTICS =================
    @GetMapping("/farmer/{farmerId}/analytics")
    public Map<String, Object> getFarmerSalesAnalytics(@PathVariable Long farmerId) {
        Map<String, Object> response = new HashMap<>();

        // Completed transactions (delivered orders)
        List<Order> completedOrders = orderRepository.findByProductFarmerIdAndStatus(farmerId, OrderStatus.DELIVERED);
        response.put("completedTransactions", completedOrders);
        System.out.println("Farmer " + farmerId + " has " + completedOrders.size() + " delivered orders");

        // Total revenue from delivered orders
        Double totalRevenue = orderRepository.sumRevenueByFarmerId(farmerId, OrderStatus.CANCELLED);
        response.put("totalRevenue", totalRevenue);

        // Monthly transaction counts for graph
        List<Object[]> monthlyTransactions = orderRepository.getMonthlyTransactionCounts(farmerId, OrderStatus.DELIVERED);
        Map<String, Integer> monthlyTransactionData = new HashMap<>();
        String[] monthNames = {"January", "February", "March", "April", "May", "June",
                              "July", "August", "September", "October", "November", "December"};

        System.out.println("Monthly transactions query returned " + monthlyTransactions.size() + " rows");
        for (Object[] row : monthlyTransactions) {
            int monthIndex = ((Number) row[0]).intValue() - 1; // MySQL months are 1-based
            int count = ((Number) row[1]).intValue();
            System.out.println("Month " + monthIndex + " has " + count + " transactions");
            if (monthIndex >= 0 && monthIndex < 12) {
                monthlyTransactionData.put(monthNames[monthIndex], count);
            }
        }
        response.put("monthlyTransactions", monthlyTransactionData);
        System.out.println("Monthly transaction data: " + monthlyTransactionData);

        // Top sold products for graph
        List<Object[]> topProducts = orderRepository.getTopSoldProducts(farmerId, OrderStatus.DELIVERED);
        List<Map<String, Object>> topProductsData = new java.util.ArrayList<>();
        System.out.println("Top products query returned " + topProducts.size() + " rows");
        for (Object[] row : topProducts) {
            Map<String, Object> product = new HashMap<>();
            product.put("name", row[0]);
            product.put("quantity", ((Number) row[1]).intValue());
            topProductsData.add(product);
            System.out.println("Product: " + row[0] + ", Quantity: " + row[1]);
        }
        response.put("topSoldProducts", topProductsData);
        System.out.println("Top products data: " + topProductsData);

        return response;
    }

    // ================= ADMIN: GET ALL ORDERS =================
    @GetMapping("/admin")
    public List<Order> getAllOrdersForAdmin() {
        return orderRepository.findAll();
    }

    // ================= UPDATE ORDER STATUS (ADMIN) =================
    @PutMapping("/admin/{orderId}/status")
    @Transactional
    public Order updateOrderStatus(
            @PathVariable Long orderId,
            @RequestBody Map<String, String> data
    ) {
        Order order = orderRepository.findById(orderId)
                .orElseThrow(() -> new RuntimeException("Order not found"));

        OrderStatus newStatus = OrderStatus.valueOf(data.get("status"));
        order.setStatus(newStatus);

        // ================= CREATE NOTIFICATIONS =================
        // Notify farmer (in-app)
        Notification farmerNotification = new Notification();
        farmerNotification.setUserId(order.getProduct().getFarmer().getId());
        farmerNotification.setMessage("Order #" + order.getId() + " status updated to " + newStatus);
        farmerNotification.setRead(false);
        farmerNotification.setCreatedAt(LocalDateTime.now());
        notificationRepository.save(farmerNotification);

        // Notify retailer (in-app)
        Notification retailerNotification = new Notification();
        retailerNotification.setUserId(order.getRetailer().getId());
        retailerNotification.setMessage("Your order #" + order.getId() + " status updated to " + newStatus);
        retailerNotification.setRead(false);
        retailerNotification.setCreatedAt(LocalDateTime.now());
        notificationRepository.save(retailerNotification);

        // ================= SEND EMAIL NOTIFICATIONS =================
        // Email farmer
        emailService.sendOrderStatusNotification(
            order.getProduct().getFarmer().getEmail(),
            order.getId().toString(),
            newStatus.toString()
        );

        // Email retailer
        emailService.sendOrderStatusNotification(
            order.getRetailer().getEmail(),
            order.getId().toString(),
            newStatus.toString()
        );

        return orderRepository.save(order);
    }

    // ================= CANCEL ORDER (ADMIN) =================
    @PutMapping("/admin/{orderId}/cancel")
    @Transactional
    public Order cancelOrder(@PathVariable Long orderId) {

        Order order = orderRepository.findById(orderId)
                .orElseThrow(() -> new RuntimeException("Order not found"));

        if (order.getStatus() == OrderStatus.CANCELLED) {
            return order;
        }

        Product product = order.getProduct();
        product.setQuantity(product.getQuantity() + order.getQuantity());
        productRepository.save(product);

        order.setStatus(OrderStatus.CANCELLED);
        return orderRepository.save(order);
    }

    // ================= ADMIN REVENUE =================
    @GetMapping("/admin/revenue")
    public Map<String, Object> getAdminRevenue() {
        Map<String, Object> response = new HashMap<>();
        response.put("totalRevenue", orderRepository.getTotalRevenue(OrderStatus.CANCELLED));
        return response;
    }

    // ================= RETAILER REVENUE =================
    @GetMapping("/retailer/{retailerId}/revenue")
    public Map<String, Object> getRetailerRevenue(@PathVariable Long retailerId) {
        Map<String, Object> response = new HashMap<>();
        response.put("totalRevenue", orderRepository.sumRevenueByRetailerId(retailerId, OrderStatus.CANCELLED));
        return response;
    }

    // ================= ADMIN ORDER COUNT =================
    @GetMapping("/admin/count")
    public long getOrderCount() {
        return orderRepository.getTotalOrders();
    }
}
